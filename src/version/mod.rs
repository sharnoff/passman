//! Abstraction over multiple versions of the file format allowed
//!
//! Because we want to continue to properly handle old config file formats - even when they'll no
//! longer be generated by default. In the future, we might provide some kind of feature-gating for
//! older versions, so that the dependencies associated only with them don't inflate compile times.
//!
//! All of the submodules here correspond to a particular version -- with the current one also
//! included. Each submodule defines a `FileContent` struct that implements the [`FileContent`]
//! trait in this module, so that we can cleanly abstract over the file format without changing the
//! logic in `crate::app`. The `FileContent` from the latest version is re-exported in this module
//! as [`CurrentFileContent`].
//!
//! Each submodule additionally defines a couple items:
//! ```ignore
//! // If this file format has been deprecated, a warning to indicate as such
//! pub const WARNING: Option<Warning> = ...;
//!
//! // Given a file that we know starts with the correct version prefix, parse it
//! //
//! // If any errors are encountered, print them and exit.
//! pub fn parse(file_content: String) -> FileContent { ... }
//! ```
//! Those are used by the `parse` function at the bottom of this file.

use serde::{Deserialize, Serialize};
use std::any::Any;
use std::fmt::{self, Display, Formatter};
use std::fs::read_to_string;
use std::ops::Range;
use std::path::Path;
use std::process::exit;
use std::time::SystemTime;

mod errors;
mod latest;
mod v0_2;
mod v0_3;
mod v0_4;

pub use errors::*;

/// Helper struct for file contents with an attached key
///
/// This is extracted into this module so that it's able to be used by multiple submodules without
/// redefinition.
pub struct Keyed<C> {
    key: Option<Vec<u8>>,
    unsaved: bool,
    content: C,
}

impl<C> Keyed<C> {
    /// Creates a new `Keyed` content without the key
    fn new(content: C) -> Self {
        Keyed {
            key: None,
            unsaved: false,
            content,
        }
    }
}

/// A particular file format, kept object-safe so that we can switch on it at runtime
///
/// The first couple methods here are for providing the "meta" methods -- the rest merely provide
/// the shared facilities for interaction with contents of the file.
pub trait FileContent {
    /// Helper function to convert to the latest version, given the user's password
    ///
    /// It's customary for this method to only convert to the next version internally, and instead
    /// rely upon that version's implementation of producing the current file content. This chain
    /// terminates with with the implementation for `CurrentFileContent`, which just returns itself.
    fn to_current(self: Box<Self>, pwd: String) -> Result<Box<CurrentFileContent>, DecryptError>;

    /// Provides the string that the file content should be written as
    ///
    /// This method is provided -- instead of directly writing to the file -- so that no error
    /// handling needs to be done within the implementation itself.
    fn write(&self) -> String;

    /// Sets the key, returning `Err` if it was invalid
    fn set_key(&mut self, key: String) -> Result<(), DecryptError>;

    /// Returns true if there have been changes made to the file without saving
    ///
    /// Changes should be registered as unsaved until a call to `saved` is made
    fn unsaved(&self) -> bool;

    /// Registers any unsaved change as now being saved
    fn mark_saved(&mut self);

    /// Returns whether the entries have been decrypted -- true after `set_key` returns `Ok`
    fn decrypted(&self) -> bool;

    /// Produces the number of entries in the file
    fn num_entries(&self) -> usize;

    /// Produces the entry corresponding to the given index
    fn entry(&self, idx: usize) -> Box<dyn EntryRef + '_>;

    /// Produces a mutable reference to the corresponding entry
    fn entry_mut(&mut self, idx: usize) -> Box<dyn EntryMut + '_>;

    /// Gives access to the specified range of entries
    ///
    /// The default implementation should suffice, but it *may* be possible for other
    /// implementations to improve the performance. In practice, the performance should not matter
    /// much.
    fn entries_range(&self, range: Range<usize>) -> Vec<Box<dyn EntryRef + '_>> {
        range.map(|i| self.entry(i)).collect()
    }

    /// Returns all of the entires
    ///
    /// The default implementation here should suffice
    fn all_entries(&self) -> Vec<Box<dyn EntryRef + '_>> {
        let len = self.num_entries();
        self.entries_range(0..len)
    }

    /// Adds an empty entry with the given name and returns its index
    fn add_empty_entry(&mut self, name: String) -> usize;

    /// Removes the entry at the given index
    fn remove_entry(&mut self, idx: usize);
}

/// An immutable handle on an entry in the file
pub trait EntryRef {
    /// Returns the title of the entry
    fn name(&self) -> &str;

    /// Returns all the tags associated with the entry
    fn tags(&self) -> Vec<&str>;

    /// Returns the date + time at which the
    fn first_added(&self) -> SystemTime;

    /// Returns the date + time the entry was last updated
    fn last_update(&self) -> SystemTime;

    /// Returns a reference to the field with index `idx`
    ///
    /// ## Panics
    ///
    /// This function *should* panic if `idx` is greater than `self.num_fields()`
    fn field(&self, idx: usize) -> Box<dyn FieldRef + '_>;

    /// Returns the number of fields in the entry
    fn num_fields(&self) -> usize;
}

/// A mutable handle on an entry in the file
pub trait EntryMut: EntryRef {
    /// Sets the title of the entry
    fn set_name(&mut self, name: String);

    /// Sets the tags associated with the entry
    fn set_tags(&mut self, tags: Vec<String>);

    /// Returns a mutable reference to the field with index `idx`
    ///
    /// ## Panics
    ///
    /// This function *should* panic if `idx` is greater than `self.num_fields()`
    fn field_mut(&mut self, idx: usize) -> Box<dyn FieldMut + '_>;

    /// Creates a `FieldBuilder` that will (possibly) later be provided back
    fn field_builder(&self) -> Box<dyn FieldBuilder>;

    /// Sets the field at the given index, using the result of a previous call to
    /// `self.field_builder()`
    ///
    /// The index may be one greater than the current number of fields, in which case the value
    /// should be appended.
    fn set_field(
        &mut self,
        idx: usize,
        builder: Box<dyn FieldBuilder>,
    ) -> Result<(), SetFieldError>;

    /// Removes the given field
    fn remove_field(&mut self, idx: usize);
}

/// An immutable handle on a single field of an entry
pub trait FieldRef {
    /// The name of the field
    fn name(&self) -> &str;

    /// Returns the type of value inside this field
    fn value_kind(&self) -> ValueKind;

    /// The value of the field
    ///
    /// For TOTP fields, this is expected to perform the necessary calculations and return the
    /// current OTP.
    fn value(&self) -> Result<String, GetValueError>;

    /// Returns the "plaintext" value of the field
    ///
    /// Unlike `value`, this returns the underlying secret for TOTP fields.
    fn plaintext_value(&self) -> Result<PlaintextValue, GetValueError>;
}

/// A mutable handle on a single field of an entry
pub trait FieldMut: FieldRef {
    /// Swaps the encryption of the field
    fn swap_encryption(&mut self) -> Result<(), SwapEncryptionError>;
}

/// The types of values a field might have
#[derive(Debug, Copy, Clone)]
pub enum ValueKind {
    Basic,
    Protected,
    Totp,
}

impl Display for ValueKind {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match self {
            ValueKind::Basic => f.write_str("Basic"),
            ValueKind::Protected => f.write_str("Protected"),
            ValueKind::Totp => f.write_str("TOTP"),
        }
    }
}

/// Helper type for constructing a field
pub trait FieldBuilder: Any {
    /// Helper method to recover the original type
    fn as_any_mut(&mut self) -> &mut dyn Any;

    /// Converts the builder to build a "manual" field
    fn make_manual(&mut self);

    /// Converts the builder to build a TOTP field
    fn make_totp(&mut self) -> Result<(), UnsupportedFeature>;

    /// Sets the name of the field
    fn set_name(&mut self, name: String);

    /// Sets the value of the field
    ///
    /// ## Panics
    ///
    /// This method panics if there was no previous successful call to the matching `make_*` method
    /// for the value (`make_manual` or `make_totp`).
    fn set_value(&mut self, value: PlaintextValue);
}

/// The latest version of the file content -- the most recent implementor of [`FileContent`]
pub type CurrentFileContent = Keyed<v0_4::FileContent>;

/// A warning given after opening a file with a particular format version
pub struct Warning {
    pub reason: &'static str,
}

/// Parses a `FileContent` from the provided file, exiting the program on failure
pub fn parse(file: &Path) -> (Box<dyn FileContent>, Option<Warning>) {
    let content = match read_to_string(file) {
        Ok(c) => c,
        Err(e) => {
            eprintln!("failed to read file {:?}: {}", file.to_string_lossy(), e);
            exit(1);
        }
    };

    macro_rules! prefix_match {
        ($val:expr => { $($str:literal => $arm:expr,)* _ => $else_arm:expr, }) => {{
            let v = $val;
            $(if v.starts_with($str) {
                $arm
            } else)* {
                $else_arm
            }
        }};
    }

    prefix_match!(content.as_str() => {
        "---\nversion: v0.2\n" => (Box::new(v0_2::parse(content)), v0_2::WARNING),
        "---\nversion: v0.3\n" => (Box::new(v0_3::parse(content)), v0_3::WARNING),
        "---\nversion: v0.4\n" => (Box::new(v0_4::parse(content)), v0_4::WARNING),
        _ => {
            eprintln!("unrecognized file version, should be one of: ['v0.2', 'v0.3', 'v0.4']");
            exit(1)
        },
    })
}

/// Return type for [`CurrentFileContent::to_plaintext`]
///
/// This is used both to convert between `FileContent` versions *and* to within the
/// `emit-plaintext` and `from-plaintext` subcommands.
#[derive(Serialize, Deserialize)]
pub struct PlaintextContent {
    last_update: SystemTime,
    entries: Vec<PlaintextEntry>,
}

#[derive(Serialize, Deserialize)]
struct PlaintextEntry {
    name: String,
    tags: Vec<String>,
    fields: Vec<PlaintextField>,
    first_added: SystemTime,
    last_update: SystemTime,
}

#[derive(Serialize, Deserialize)]
struct PlaintextField {
    name: String,
    value: PlaintextValue,
}

#[derive(Serialize, Deserialize)]
pub enum PlaintextValue {
    Manual { value: String, protected: bool },
    Totp { secret: String, issuer: String },
}

impl PlaintextContent {
    /// Produces a new, empty `PlaintextContent` with the current time as its last update
    fn init() -> Self {
        PlaintextContent {
            last_update: SystemTime::now(),
            entries: Vec::new(),
        }
    }
}
