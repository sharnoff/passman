//! Abstraction over multiple versions of the file format allowed
//!
//! Because we want to continue to properly handle old config file formats - even when they'll no
//! longer be generated by default. In the future, we might provide some kind of feature-gating for
//! older versions, so that the dependencies associated only with them don't inflate compile times.
//!
//! All of the submodules here correspond to a particular version -- with the current one also
//! included. Each submodule defines a `FileContent` struct that implements the [`FileContent`]
//! trait in this module, so that we can cleanly abstract over the file format without changing the
//! logic in `crate::app`. The `FileContent` from the latest version is re-exported in this module
//! as [`CurrentFileContent`].
//!
//! Each submodule additionally defines a couple items:
//! ```ignore
//! // If this file format has been deprecated, a warning to indicate as such
//! pub const WARNING: Option<Warning> = ...;
//!
//! // Given a file that we know starts with the correct version prefix, parse it
//! //
//! // If any errors are encountered, print them and exit.
//! pub fn parse(file_content: String) -> FileContent { ... }
//! ```
//! Those are used by the `parse` function at the bottom of this file.

use serde::{Deserialize, Serialize};
use std::fs::read_to_string;
use std::ops::Range;
use std::path::Path;
use std::process::exit;
use std::time::SystemTime;

mod latest;
mod v0_2;
mod v0_3;

/// Helper struct for file contents with an attached key
///
/// This is extracted into this module so that it's able to be used by multiple submodules without
/// redefinition.
pub struct Keyed<C> {
    key: Option<Vec<u8>>,
    unsaved: bool,
    content: C,
}

impl<C> Keyed<C> {
    /// Creates a new `Keyed` content without the key
    fn new(content: C) -> Self {
        Keyed {
            key: None,
            unsaved: false,
            content,
        }
    }
}

/// A particular file format, kept object-safe so that we can switch on it at runtime
///
/// The first couple methods here are for providing the "meta" methods -- the rest merely provide
/// the shared facilities for interaction with contents of the file.
pub trait FileContent {
    /// Helper function to convert to the latest version, given the user's password
    ///
    /// It's customary for this method to only convert to the next version internally, and instead
    /// rely upon that version's implementation of producing the current file content. This chain
    /// terminates with with the implementation for `CurrentFileContent`, which just returns itself.
    fn to_current(self: Box<Self>, pwd: String) -> Result<Box<CurrentFileContent>, ()>;

    /// Provides the string that the file content should be written as
    ///
    /// This method is provided -- instead of directly writing to the file -- so that no error
    /// handling needs to be done within the implementation itself.
    fn write(&self) -> String;

    /// Sets the key, returning `Err` if it was invalid
    fn set_key(&mut self, key: String) -> Result<(), ()>;

    /// Returns true if there have been changes made to the file without saving
    ///
    /// Changes should be registered as unsaved until a call to `saved` is made
    fn unsaved(&self) -> bool;

    /// Registers any unsaved change as now being saved
    fn mark_saved(&mut self);

    /// Returns whether the entries have been decrypted -- true after `set_key` returns `Ok`
    fn decrypted(&self) -> bool;

    /// Produces the number of entries in the file
    fn num_entries(&self) -> usize;

    /// Produces the entry corresponding to the given index
    fn entry(&self, idx: usize) -> Box<dyn EntryRef + '_>;

    /// Produces a mutable reference to the corresponding entry
    fn entry_mut(&mut self, idx: usize) -> Box<dyn EntryMut + '_>;

    /// Gives access to the specified range of entries
    ///
    /// The default implementation should suffice, but it *may* be possible for other
    /// implementations to improve the performance. In practice, the performance should not matter
    /// much.
    fn entries_range(&self, range: Range<usize>) -> Vec<Box<dyn EntryRef + '_>> {
        range.map(|i| self.entry(i)).collect()
    }

    /// Returns all of the entires
    ///
    /// The default implementation here should suffice
    fn all_entries(&self) -> Vec<Box<dyn EntryRef + '_>> {
        let len = self.num_entries();
        self.entries_range(0..len)
    }

    /// Adds an empty entry with the given name and returns the value
    fn add_empty_entry(&mut self, name: String) -> usize;

    /// Removes the specified entry
    fn remove_entry(&mut self, idx: usize);
}

/// An immutable handle on an entry in the file
pub trait EntryRef {
    /// Returns the title of the entry
    fn name(&self) -> &str;

    /// Returns all the tags associated with the entry
    fn tags(&self) -> Vec<&str>;

    /// Returns the date + time at which the
    fn first_added(&self) -> SystemTime;

    /// Returns the date + time the entry was last updated
    fn last_update(&self) -> SystemTime;

    /// Returns whether the particular field is protected
    fn field_protected(&self, idx: usize) -> bool;

    /// Returns the name of the field
    fn field_name(&self, idx: usize) -> &str;

    /// The value of the field corresponding to the given index, given the key
    ///
    /// This should return `Err` exactly when the key hasn't been set and the field is protected.
    fn field_value(&self, idx: usize) -> Result<String, ()>;

    /// Returns the number of fields in the entry
    fn num_fields(&self) -> usize;
}

/// A mutable handle on an entry in the file
pub trait EntryMut: EntryRef {
    /// Sets the title of the entry
    fn set_name(&mut self, name: String);

    /// Sets the tags associated with the entry
    fn set_tags(&mut self, tags: Vec<String>);

    /// Sets the name and value of the field
    fn set_field(&mut self, idx: usize, name: String, value: String);

    /// Swaps the encryption of the field
    fn swap_encryption(&mut self, idx: usize) -> Result<(), ()>;

    /// Adds an unprotected field with the provided name and value
    fn push_field(&mut self, name: String, value: String);

    /// Removes the given field
    fn remove_field(&mut self, idx: usize);
}

/// The latest version of the file content -- the most recent implementor of [`FileContent`]
pub type CurrentFileContent = Keyed<v0_3::FileContent>;

/// A warning given after opening a file with a particular format version
pub struct Warning {
    pub reason: &'static str,
}

/// Parses a `FileContent` from the provided file, exiting the program on failure
pub fn parse(file: &Path) -> (Box<dyn FileContent>, Option<Warning>) {
    let content = match read_to_string(file) {
        Ok(c) => c,
        Err(e) => {
            eprintln!("failed to read file {:?}: {}", file.to_string_lossy(), e);
            exit(1);
        }
    };

    macro_rules! prefix_match {
        ($val:expr => { $($str:literal => $arm:expr,)* _ => $else_arm:expr, }) => {{
            let v = $val;
            $(if v.starts_with($str) {
                $arm
            } else)* {
                $else_arm
            }
        }};
    }

    prefix_match!(content.as_str() => {
        "---\nversion: v0.2\n" => (Box::new(v0_2::parse(content)), v0_2::WARNING),
        "---\nversion: v0.3\n" => (Box::new(v0_3::parse(content)), v0_3::WARNING),
        _ => {
            eprintln!("unrecognized file version, should be one of: ['v0.2', 'v0.3']");
            exit(1)
        },
    })
}

/// Return type for [`CurrentFileContent::to_plaintext`]
///
/// This is used both to convert between `FileContent` versions *and* to within the
/// `emit-plaintext` and `from-plaintext` subcommands.
#[derive(Serialize, Deserialize)]
pub struct PlaintextContent {
    last_update: SystemTime,
    entries: Vec<PlaintextEntry>,
}

#[derive(Serialize, Deserialize)]
struct PlaintextEntry {
    name: String,
    tags: Vec<String>,
    fields: Vec<PlaintextField>,
    first_added: SystemTime,
    last_update: SystemTime,
}

#[derive(Serialize, Deserialize)]
struct PlaintextField {
    name: String,
    value: String,
    protected: bool,
}

impl PlaintextContent {
    /// Produces a new, empty `PlaintextContent` with the current time as its last update
    fn init() -> Self {
        PlaintextContent {
            last_update: SystemTime::now(),
            entries: Vec::new(),
        }
    }
}
